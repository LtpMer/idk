<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal AI Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module" src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js"></script>
    <script type="module" src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js"></script>
    <script type="module" src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"></script>
    <!-- Tone.js for sounds -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            background-color: #1a1a2e; /* Deep purple-blue */
            color: #e0e0e0;
        }
        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        .panel {
            background-color: #2e0f4f; /* Darker purple */
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            margin: 1rem;
            overflow-y: auto;
            flex-shrink: 0;
        }
        .left-panel {
            width: 300px; /* Adjusted width for material inputs */
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top */
            position: relative;
            margin: 1rem;
            background-color: #2e0f4f; /* Darker purple */
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 2rem;
            overflow-y: auto; /* Make main content scrollable */
        }
        /* Shared Dropzone Styles */
        #dna-strand-dropzone, #material-composition-dropzone-outer { /* Added outer div for material dropzone for consistent styling */
            min-height: 100px;
            border: 2px dashed #6a05ad;
            background-color: #1b0a2d;
            border-radius: 0.75rem;
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 1rem;
            align-items: center;
            justify-content: center;
            width: 90%; /* DNA dropzone width */
            max-width: 800px; /* DNA dropzone max-width */
        }
        #material-composition-dropzone-outer { /* Specific styling for the material dropzone container */
            width: 100%; /* Fill parent width */
            max-width: none; /* No max width for material dropzone */
        }

        .dna-component, .material-component {
            background-color: #8d4af7;
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            cursor: grab;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.1s ease-out;
        }
        .dna-component:active, .material-component:active {
            cursor: grabbing;
            transform: scale(1.05);
        }
        .dna-component-dragged, .material-component-dragged {
            position: absolute;
            z-index: 1000;
            opacity: 0.8;
            pointer-events: none;
        }
        .dna-strand-item, .material-composition-item {
            background-color: #7f38d3;
            color: white;
            padding: 0.6rem 1rem;
            border-radius: 0.4rem;
            font-size: 0.9em;
            cursor: pointer; /* Change to pointer for clickable remove */
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1);
        }
        #creature-image-container, #material-image-container {
            width: 100%;
            height: calc(100% - 250px); /* Adjust height for dropzone and buttons */
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #1b0a2d;
            border-radius: 0.75rem;
            overflow: hidden;
        }
        #creature-image, #material-image {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 0.5rem;
        }

        /* Mode Specific Styles */
        label {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #d1c4e9;
        }
        input[type="text"], textarea, select {
            background-color: #1b0a2d;
            border: 1px solid #6a05ad;
            border-radius: 0.5rem;
            padding: 0.75rem;
            color: #e0e0e0;
            width: 100%;
            box-sizing: border-box;
        }
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        #material-description-output, #math-description-output, #fractal-description-output { /* Re-used for Math/Fractal Mode description */
            background-color: #1b0a2d;
            border: 1px dashed #6a05ad;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 150px;
            overflow-y: auto;
            color: #e0e0e0;
            width: 100%;
            box-sizing: border-box;
            line-height: 1.6;
        }
        #math-result-output, #fractal-coords-output {
            background-color: #1b0a2d;
            border: 1px dashed #6a05ad;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-top: 1rem;
            font-size: 1.2em;
            color: #a64ac9;
            width: 100%;
            text-align: center;
        }
        #shape-canvas, #fractal-canvas {
            background-color: #1b0a2d;
            border: 1px solid #6a05ad;
            border-radius: 0.75rem;
            margin-top: 1.5rem;
            max-width: 100%;
            aspect-ratio: 1 / 1; /* Keep square aspect ratio */
            box-sizing: border-box; /* Include padding and border in width/height */
        }
        #fractal-canvas {
            width: 100%; /* Make it fill available width */
            height: 400px; /* Fixed height for now, adjust as needed */
            cursor: crosshair;
        }
        .fractal-zoom-buttons, .fractal-4d-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }


        /* General Button Styles */
        button {
            background-image: linear-gradient(to right, #6a05ad, #a64ac9);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 0.75rem;
            border: none;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease-in-out;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        /* Mode Buttons */
        .mode-button-group {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .mode-button {
            background-image: linear-gradient(to right, #4a0270, #7c3aed);
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            font-weight: normal;
        }
        .mode-button.active {
            background-image: linear-gradient(to right, #6a05ad, #a64ac9);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
            font-weight: bold;
        }
        .sub-mode-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1rem;
            padding: 0.75rem;
            background-color: #1b0a2d;
            border-radius: 0.75rem;
            border: 1px solid #4a0270;
        }
        .sub-mode-group label {
            font-weight: normal;
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .sub-mode-group input[type="radio"] {
            margin-right: 0.5rem;
            accent-color: #a64ac9; /* Highlight radio button */
            width: auto; /* Override default input width */
        }
        .radio-button-group {
            display: flex;
            gap: 1rem;
            justify-content: flex-start;
            flex-wrap: wrap; /* Allow wrapping for more options */
        }

        /* Loading & Message Box */
        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #1b0a2d;
            opacity: 0.9;
            border: 2px solid #6a05ad;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            z-index: 1001;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            text-align: center;
        }
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #1b0a2d;
            border: 2px solid #6a05ad;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            z-index: 1002;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            text-align: center;
        }
        #message-box-content {
            font-size: 1.1em;
            color: #e0e0e0;
            max-height: 300px;
            overflow-y: auto;
            padding-right: 10px;
        }
        #message-box-close {
            background-image: linear-gradient(to right, #a64ac9, #6a05ad);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .settings-content {
            background-color: #2e0f4f;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            width: 90%;
            max-width: 500px;
            color: #e0e0e0;
        }
        .settings-content h3 {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #d1c4e9;
        }
        .settings-content p {
            margin-bottom: 1.5rem;
        }
        .settings-content button {
            margin-top: 1rem;
        }
        .settings-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #4a0270;
        }
        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .settings-checkbox-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .settings-checkbox-group input[type="checkbox"] {
            width: auto;
            height: 1.2em;
            accent-color: #a64ac9;
            cursor: pointer;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="left-panel panel">
            <h2 class="text-xl font-bold text-center text-purple-200 mb-4">Generator Mode</h2>
            <div class="mode-button-group">
                <button id="trait-mode-button" class="mode-button active">Trait Mode</button>
                <button id="dna-mode-button" class="mode-button">DNA Mode</button>
                <button id="material-mode-button" class="mode-button">Material Mode</button>
                <button id="math-mode-button" class="mode-button">Math Mode</button>
                <button id="fractal-mode-button" class="mode-button">Fractal Mode</button> <!-- New Fractal Mode Button -->
            </div>

            <!-- DNA/Creature Controls (visible in Trait/DNA modes) -->
            <div id="creature-controls">
                <h2 class="text-xl font-bold text-center text-purple-200 mt-6 mb-4">DNA Components</h2>
                <div id="dna-components-palette" class="grid grid-cols-2 gap-3">
                    <!-- DNA Components will be populated here by JS -->
                </div>
                <h2 class="text-xl font-bold text-center text-purple-200 mt-6 mb-4">Preset Beings</h2>
                <div id="preset-buttons-container" class="grid grid-cols-2 gap-3">
                    <button id="preset-human" class="preset-button">Humanoid</button>
                    <button id="preset-aquatic" class="preset-button">Aquatic</button>
                    <button id="preset-avian" class="preset-button">Avian</button>
                    <button id="preset-reptilian" class="preset-button">Reptilian</button>
                </div>
            </div>

            <!-- Material Controls (visible in Material mode) -->
            <div id="material-controls" class="hidden">
                <h2 class="text-xl font-bold text-center text-purple-200 mt-6 mb-4">Material Input Type</h2>
                <div class="sub-mode-group">
                    <div class="radio-button-group">
                        <label><input type="radio" name="material-input-type" value="manual" id="material-input-manual" checked> Manual Input</label>
                        <label><input type="radio" name="material-input-type" value="drag_drop" id="material-input-drag-drop"> Drag & Drop Input</label>
                    </div>
                </div>

                <!-- Manual Material Inputs (initially visible in Material mode) -->
                <div id="manual-material-inputs">
                    <h2 class="text-xl font-bold text-center text-purple-200 mt-6 mb-4">Material Properties</h2>
                    <label for="material-name">Material Name (Optional):</label>
                    <input type="text" id="material-name" placeholder="e.g., Chronium, Quantum Glass">

                    <label for="material-state">State:</label>
                    <select id="material-state">
                        <option value="solid">Solid</option>
                        <option value="liquid">Liquid</option>
                        <option value="gas">Gas</option>
                        <option value="plasma">Plasma</option>
                        <option value="other">Other/Variable</option>
                    </select>

                    <label for="material-properties">Key Properties (comma-separated):</label>
                    <textarea id="material-properties" placeholder="e.g., Hard, Transparent, Conductive, Self-repairing, Bioluminescent"></textarea>

                    <label for="material-chemistry">Chemistry/Composition (Optional):</label>
                    <textarea id="material-chemistry" placeholder="e.g., Stable Isotope of Element X, Polymer based on Carbon-Nitrogen chains, Nanobots"></textarea>

                    <label for="material-use">Intended Use/Application (Optional):</label>
                    <textarea id="material-use" placeholder="e.g., Spaceship hull, Energy storage, Medical implant, Living building material"></textarea>
                </div>

                <!-- Drag & Drop Material Palette (initially hidden) -->
                <div id="material-drag-palette" class="hidden grid grid-cols-2 gap-3 mt-6">
                    <!-- Material Components will be populated here by JS -->
                </div>
            </div>

            <!-- Math Controls (visible in Math mode) -->
            <div id="math-controls" class="hidden">
                <h2 class="text-xl font-bold text-center text-purple-200 mt-6 mb-4">Mathematical Operations</h2>
                <label for="math-expression">Enter Math Expression:</label>
                <input type="text" id="math-expression" placeholder="e.g., 5 * (10 + 2) / 3 or sqrt(81)">

                <h2 class="text-xl font-bold text-center text-purple-200 mt-6 mb-4">Shape Visualization</h2>
                <label for="shape-type">Shape Type (e.g., square, circle, triangle, rectangle):</label>
                <input type="text" id="shape-type" placeholder="e.g., square">

                <label for="shape-number">Shape Parameter(s) (e.g., 5 for side/radius, 6,4 for rect width,height):</label>
                <input type="text" id="shape-number" placeholder="e.g., 5 or 6,4">
            </div>

            <!-- Fractal Controls (visible in Fractal mode) -->
            <div id="fractal-controls" class="hidden">
                <h2 class="text-xl font-bold text-center text-purple-200 mt-6 mb-4">Fractal Parameters</h2>
                <label for="fractal-type">Fractal Type:</label>
                <select id="fractal-type">
                    <option value="mandelbrot">Mandelbrot Set</option>
                    <option value="julia">Julia Set</option>
                </select>

                <div id="julia-params" class="hidden">
                    <label for="julia-cx">Julia C (Real):</label>
                    <input type="text" id="julia-cx" value="-0.70176" placeholder="e.g., -0.70176">
                    <label for="julia-cy">Julia C (Imaginary):</label>
                    <input type="text" id="julia-cy" value="-0.3842" placeholder="e.g., -0.3842">
                </div>

                <label for="max-iterations">Max Iterations:</label>
                <input type="number" id="max-iterations" value="100" min="50" max="500">

                <div class="fractal-zoom-buttons">
                    <button id="zoom-in-button">Zoom In</button>
                    <button id="zoom-out-button">Zoom Out</button>
                </div>

                <h2 class="text-xl font-bold text-center text-purple-200 mt-6 mb-4">4D Exploration (AI Described)</h2>
                <div class="fractal-4d-buttons">
                    <button id="rotate-4d-x">Rotate 4D X</button>
                    <button id="rotate-4d-y">Rotate 4D Y</button>
                    <!-- Add more 4D rotation axes if desired -->
                </div>
            </div>

            <p class="text-sm text-center mt-auto text-purple-300">User ID: <span id="user-id-display">Loading...</span></p>
        </div>

        <div class="main-content">
            <h1 id="main-title" class="text-3xl font-bold text-center text-purple-200 mb-4">Creature Synthesizer</h1>

            <div class="flex gap-4 mb-4">
                <button id="generate-button">Generate</button>
                <button id="clear-all-button">Clear All</button>
                <button id="settings-button">Settings</button>
            </div>

            <!-- Creature Display Area -->
            <div id="creature-display-area">
                <div id="creature-image-container">
                    <img id="creature-image" src="" alt="Generated Creature" style="display: none;">
                    <p id="image-placeholder" class="text-lg text-purple-400">Your creature will appear here!</p>
                </div>
                <!-- DNA Strand Dropzone moved to bottom of creature display area -->
                <div id="dna-strand-dropzone" class="mb-4">
                    <p class="text-lg text-purple-400">Drag DNA components here to build your creature's genetic code.</p>
                </div>
            </div>

            <!-- Material Output Area (initially hidden) -->
            <div id="material-output-area" class="hidden w-full">
                <!-- Material Description & Image are always together now -->
                <h2 class="text-xl font-bold text-purple-200 mt-4 mb-2">Material Description:</h2>
                <div id="material-description-output">
                    <p class="text-lg text-purple-400">Your material description will appear here.</p>
                </div>

                <h2 class="text-xl font-bold text-purple-200 mt-6 mb-2">Material Image:</h2>
                <div id="material-image-container">
                    <img id="material-image" src="" alt="Generated Material Image" style="display: none;">
                    <p id="material-image-placeholder" class="text-lg text-purple-400">Your material image will appear here.</p>
                </div>
                <!-- Material Composition Dropzone moved to bottom of material output area -->
                <div id="material-composition-dropzone-outer" class="hidden mt-6">
                    <h2 class="text-xl font-bold text-purple-200 mb-2">Material Composition Dropzone</h2>
                    <div class="min-h-[100px] border-2 border-dashed border-[#6a05ad] bg-[#1b0a2d] rounded-xl p-4 flex flex-wrap gap-2 items-center justify-center" id="material-composition-content">
                        <p class="text-lg text-purple-400">Drag material components here to build your material.</p>
                    </div>
                </div>
            </div>

            <!-- Math Display Area (initially hidden) -->
            <div id="math-display-area" class="hidden w-full">
                <h2 class="text-xl font-bold text-purple-200 mt-4 mb-2">Numerical Result:</h2>
                <div id="math-result-output">
                    <p class="text-lg text-purple-400">Calculation result will appear here.</p>
                </div>

                <h2 class="text-xl font-bold text-purple-200 mt-6 mb-2">Shape Visualization:</h2>
                <canvas id="shape-canvas" width="300" height="300"></canvas>

                <h2 class="text-xl font-bold text-purple-200 mt-6 mb-2">Shape Description:</h2>
                <div id="math-description-output">
                    <p class="text-lg text-purple-400">Shape description and properties will appear here.</p>
                </div>
            </div>

            <!-- Fractal Display Area (initially hidden) -->
            <div id="fractal-display-area" class="hidden w-full flex flex-col items-center">
                <h2 class="text-xl font-bold text-purple-200 mt-4 mb-2">Fractal View:</h2>
                <canvas id="fractal-canvas"></canvas>
                <div id="fractal-coords-output" class="mt-2 text-sm">
                    <p>X: <span id="fractal-xmin-display">-2.5</span> to <span id="fractal-xmax-display">1.5</span></p>
                    <p>Y: <span id="fractal-ymin-display">-1.5</span> to <span id="fractal-ymax-display">1.5</span></p>
                </div>
                <h2 class="text-xl font-bold text-purple-200 mt-6 mb-2">4D Rotation AI Description:</h2>
                <div id="fractal-description-output">
                    <p class="text-lg text-purple-400">AI descriptions of 4D rotations will appear here.</p>
                </div>
            </div>


            <div id="loading-indicator" class="hidden">
                Generating...
            </div>
        </div>
    </div>

    <div id="message-box" class="hidden">
        <p id="message-box-content"></p>
        <button id="message-box-close">Close</button>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="settings-modal hidden">
        <div class="settings-content">
            <h3>Settings</h3>
            <div class="settings-section">
                <h4 class="text-lg font-bold text-purple-300 mb-2">Sound Settings</h4>
                <div class="settings-checkbox-group">
                    <label for="enable-sounds-checkbox">Enable All Sounds</label>
                    <input type="checkbox" id="enable-sounds-checkbox" checked>
                </div>
            </div>
            <p>This is where future settings will be configured!</p>
            <button id="close-settings-modal">Close</button>
        </div>
    </div>

    <script type="module">
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getFirestore, collection, addDoc, serverTimestamp, doc, setDoc, getDoc } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        // Initialize Firebase
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        let userId = '';
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Declare drag-related variables at the top level
        let currentDraggedElement = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // --- Tone.js Sound Setup ---
        const clickSynth = new Tone.MembraneSynth().toDestination();
        const dropSynth = new Tone.Synth().toDestination();
        const removeSynth = new Tone.Synth().toDestination();
        const generateSynth = new Tone.Synth().toDestination();
        // Laser sound
        const laserSynth = new Tone.AMSynth({
            envelope: {
                attack: 0.01,
                decay: 0.1,
                sustain: 0.7,
                release: 0.5
            },
            oscillator: { type: "sine" },
            modulation: { type: "square" },
            modulationEnvelope: {
                attack: 0.05,
                decay: 0.2,
                sustain: 0.1,
                release: 0.5
            }
        }).toDestination();
        let isLaserActive = false;
        let soundsEnabled = true; // Global sound setting


        function playClickSound() {
            if (soundsEnabled) {
                Tone.context.resume(); // Ensure audio context is resumed
                clickSynth.triggerAttackRelease("C4", "8n");
            }
        }
        function playDropSound() {
            if (soundsEnabled) {
                Tone.context.resume();
                dropSynth.triggerAttackRelease("E5", "16n", "+0.05", 0.7);
            }
        }
        function playRemoveSound() {
            if (soundsEnabled) {
                Tone.context.resume();
                removeSynth.triggerAttackRelease("G3", "16n", "+0.05", 0.7);
            }
        }
        function playGenerateSuccessSound() {
            if (soundsEnabled) {
                Tone.context.resume();
                const now = Tone.now();
                generateSynth.triggerAttackRelease("C5", "8n", now);
                generateSynth.triggerAttackRelease("E5", "8n", now + 0.1);
                generateSynth.triggerAttackRelease("G5", "8n", now + 0.2);
            }
        }
        function playLaserSound(frequency) {
            if (soundsEnabled) {
                Tone.context.resume();
                if (!isLaserActive) {
                    laserSynth.triggerAttack(frequency);
                    isLaserActive = true;
                } else {
                    laserSynth.set({ frequency: frequency });
                }
            }
        }
        function stopLaserSound() {
            if (isLaserActive) {
                laserSynth.triggerRelease();
                isLaserActive = false;
            }
        }


        // Firebase Auth State Listener
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                document.getElementById('user-id-display').textContent = userId;
                await loadSoundSetting(); // Load sound setting after user is authenticated
            } else {
                try {
                    if (typeof __initial_auth_token !== 'undefined') {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Firebase authentication error:", error);
                    showMessageBox("Authentication failed. Please refresh the page.");
                }
            }
        });

        // Message Box functionality
        function showMessageBox(message) {
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-box-content').textContent = message;
            msgBox.style.display = 'flex';
        }

        document.getElementById('message-box-close').addEventListener('click', () => {
            document.getElementById('message-box').style.display = 'none';
        });

        // --- DOM Elements ---
        // Mode buttons
        const traitModeButton = document.getElementById('trait-mode-button');
        const dnaModeButton = document.getElementById('dna-mode-button');
        const materialModeButton = document.getElementById('material-mode-button');
        const mathModeButton = document.getElementById('math-mode-button');
        const fractalModeButton = document.getElementById('fractal-mode-button');

        // Left Panel Controls
        const creatureControls = document.getElementById('creature-controls');
        const materialControls = document.getElementById('material-controls');
        const mathControls = document.getElementById('math-controls');
        const fractalControls = document.getElementById('fractal-controls');

        const dnaComponentsPalette = document.getElementById('dna-components-palette');
        const presetButtonsContainer = document.getElementById('preset-buttons-container');

        // Material Mode Sub-Controls
        const materialInputManualRadio = document.getElementById('material-input-manual');
        const materialInputDragDropRadio = document.getElementById('material-input-drag-drop');

        // Manual Material Inputs
        const manualMaterialInputsDiv = document.getElementById('manual-material-inputs');
        const materialNameInput = document.getElementById('material-name');
        const materialStateSelect = document.getElementById('material-state');
        const materialPropertiesTextarea = document.getElementById('material-properties');
        const materialChemistryTextarea = document.getElementById('material-chemistry');
        const materialUseTextarea = document.getElementById('material-use');

        // Drag & Drop Material Palette and Dropzone
        const materialDragPalette = document.getElementById('material-drag-palette');
        // Renamed materialCompositionDropzone to materialCompositionDropzoneOuter for better clarity in HTML/JS
        const materialCompositionDropzoneOuter = document.getElementById('material-composition-dropzone-outer');
        const materialCompositionContent = document.getElementById('material-composition-content');

        // Math Mode Inputs
        const mathExpressionInput = document.getElementById('math-expression');
        const shapeTypeInput = document.getElementById('shape-type');
        const shapeNumberInput = document.getElementById('shape-number');

        // Fractal Mode Inputs
        const fractalTypeSelect = document.getElementById('fractal-type');
        const juliaParamsDiv = document.getElementById('julia-params');
        const juliaCxInput = document.getElementById('julia-cx');
        const juliaCyInput = document.getElementById('julia-cy');
        const maxIterationsInput = document.getElementById('max-iterations');
        const zoomInButton = document.getElementById('zoom-in-button');
        const zoomOutButton = document.getElementById('zoom-out-button');
        const rotate4dXButton = document.getElementById('rotate-4d-x');
        const rotate4dYButton = document.getElementById('rotate-4d-y');


        // Main Content Output Areas
        const mainTitle = document.getElementById('main-title');
        const creatureDisplayArea = document.getElementById('creature-display-area');
        const dnaStrandDropzone = document.getElementById('dna-strand-dropzone');
        const creatureImageContainer = document.getElementById('creature-image-container');
        const creatureImage = document.getElementById('creature-image');
        const imagePlaceholder = document.getElementById('image-placeholder');

        const materialOutputArea = document.getElementById('material-output-area');
        const materialImageContainer = document.getElementById('material-image-container');
        const materialImage = document.getElementById('material-image');
        const materialImagePlaceholder = document.getElementById('material-image-placeholder');
        const materialDescriptionOutput = document.getElementById('material-description-output');

        const mathDisplayArea = document.getElementById('math-display-area');
        const mathResultOutput = document.getElementById('math-result-output');
        const shapeCanvas = document.getElementById('shape-canvas');
        const ctxShape = shapeCanvas.getContext('2d');
        const mathDescriptionOutput = document.getElementById('math-description-output');

        const fractalDisplayArea = document.getElementById('fractal-display-area');
        const fractalCanvas = document.getElementById('fractal-canvas');
        const ctxFractal = fractalCanvas.getContext('2d');
        const fractalXminDisplay = document.getElementById('fractal-xmin-display');
        const fractalXmaxDisplay = document.getElementById('fractal-xmax-display');
        const fractalYminDisplay = document.getElementById('fractal-ymin-display');
        const fractalYmaxDisplay = document.getElementById('fractal-ymax-display');
        const fractalDescriptionOutput = document.getElementById('fractal-description-output');


        // General Buttons
        const generateButton = document.getElementById('generate-button');
        const clearAllButton = document.getElementById('clear-all-button');
        const settingsButton = document.getElementById('settings-button');
        const loadingIndicator = document.getElementById('loading-indicator');

        // Settings Modal
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsModalButton = document.getElementById('close-settings-modal');
        const enableSoundsCheckbox = document.getElementById('enable-sounds-checkbox');


        // --- State Variables ---
        let dnaSequence = [];
        let materialComposition = [];
        let currentMode = 'trait';
        let currentMaterialInputMode = 'manual';

        // Fractal state variables
        let xMin = -2.5, xMax = 1.5, yMin = -1.5, yMax = 1.5;
        const zoomFactor = 0.5;
        let isDrawingLaser = false;

        // --- Data Definitions ---
        const traitComponents = [
            "Photosynthesis", "Predator", "Herbivore", "Carnivore", "Omnivore",
            "Bipedal", "Quadrupedal", "Hexapodal", "No Legs",
            "Legs (2)", "Legs (4)", "Legs (6+)", "No Arms", "Arms (2)", "Arms (4)", "Arms (6+)",
            "Large Eyes", "Small Eyes", "Compound Eyes", "No Eyes",
            "Eyes (1)", "Eyes (2)", "Eyes (3-5)", "Eyes (6+)",
            "Fins", "Wings", "Exoskeleton", "Soft Skin", "Scales", "Fur", "Feathers",
            "Sonar", "Sharp Claws", "Blunt Claws", "Webbed Feet", "Suction Cups",
            "Long Tail", "Short Tail", "No Tail", "Prehensile Tail",
            "Gills", "Lungs", "Amphibious",
            "Spikes", "Horns", "Antennae", "Bioluminescence",
            "Warm-blooded", "Cold-blooded",
            "Fast", "Slow", "Strong", "Weak", "Intelligent", "Simple Mind",
            "Mimicry", "Camouflage", "Venomous", "Electric Pulse",
            "Regeneration", "Elasticity", "Hard Shell", "Liquid Form"
        ];

        const dnaBaseComponents = [
            "Adenine (A)", "Thymine (T)", "Cytosine (C)", "Guanine (G)",
            "Phosphate-Sugar Backbone", "Hydrogen Bond"
        ];

        const materialComponents = [
            "Carbon", "Iron", "Silicon", "Gold", "Water", "Hydrogen", "Oxygen", "Nitrogen", "Aluminum", "Copper",
            "Metallic", "Ceramic", "Polymer", "Amorphous", "Crystalline",
            "Transparent", "Opaque", "Translucent", "Reflective", "Absorbent",
            "Conductive (Electrical)", "Insulating (Electrical)", "Conductive (Thermal)", "Insulating (Thermal)",
            "Flexible", "Rigid", "Elastic", "Brittle", "Malleable", "Ductile",
            "Liquid (Viscous)", "Liquid (Low Viscosity)", "Gas (Light)", "Gas (Dense)", "Plasma (Stable)", "Plasma (Volatile)",
            "Superconducting", "Self-repairing", "Bioluminescent", "Radioactive", "Non-reactive", "Catalytic",
            "Hard", "Soft", "Rough", "Smooth", "Porous", "Dense",
            "Powder Form", "Sheet Form", "Rod Form", "Filament Form", "Gel Form", "Nanostructure"
        ];

        const presetDNAs = {
            humanoid: { mode: 'trait', sequence: ["Bipedal", "Soft Skin", "Eyes (2)", "Legs (2)", "Arms (2)", "Lungs", "Intelligent", "Omnivore"] },
            aquatic: { mode: 'trait', sequence: ["Fins", "Gills", "Scales", "Webbed Feet", "No Legs", "Cold-blooded", "Prehensile Tail"] },
            avian: { mode: 'trait', sequence: ["Wings", "Feathers", "Bipedal", "Legs (2)", "Arms (2)", "Lungs", "Eyes (2)", "Fast"] },
            reptilian: { mode: 'trait', sequence: ["Scales", "Quadrupedal", "Legs (4)", "No Arms", "Cold-blooded", "Long Tail", "Sharp Claws", "Venomous"] }
        };

        // --- Event Listeners ---
        traitModeButton.addEventListener('click', () => setMode('trait'));
        dnaModeButton.addEventListener('click', () => setMode('dna_bases'));
        materialModeButton.addEventListener('click', () => setMode('material'));
        mathModeButton.addEventListener('click', () => setMode('math'));
        fractalModeButton.addEventListener('click', () => setMode('fractal'));

        materialInputManualRadio.addEventListener('change', () => setMaterialInputMode('manual'));
        materialInputDragDropRadio.addEventListener('change', () => setMaterialInputMode('drag_drop'));

        fractalTypeSelect.addEventListener('change', () => {
            juliaParamsDiv.classList.toggle('hidden', fractalTypeSelect.value !== 'julia');
            drawFractal();
        });
        zoomInButton.addEventListener('click', () => zoomFractal(1));
        zoomOutButton.addEventListener('click', () => zoomFractal(-1));
        rotate4dXButton.addEventListener('click', () => generate4DRotationDescription('X'));
        rotate4dYButton.addEventListener('click', () => generate4DRotationDescription('Y'));

        // Fractal Canvas Interaction
        fractalCanvas.addEventListener('click', (e) => {
            if (currentMode === 'fractal') {
                const rect = fractalCanvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                const newCenterX = xMin + (clickX / fractalCanvas.width) * (xMax - xMin);
                const newCenterY = yMin + (clickY / fractalCanvas.height) * (yMax - yMin);

                const newWidth = (xMax - xMin) * zoomFactor;
                const newHeight = (yMax - yMin) * zoomFactor;

                xMin = newCenterX - newWidth / 2;
                xMax = newCenterX + newWidth / 2;
                yMin = newCenterY - newHeight / 2;
                yMax = newCenteY + newHeight / 2;

                drawFractal();
                updateFractalCoordsDisplay();
            }
        });

        fractalCanvas.addEventListener('mousedown', (e) => {
            if (currentMode === 'fractal' && e.button === 0) {
                isDrawingLaser = true;
                fractalCanvas.addEventListener('mousemove', handleLaserMove);
            }
        });

        fractalCanvas.addEventListener('mouseup', () => {
            if (currentMode === 'fractal') {
                isDrawingLaser = false;
                fractalCanvas.removeEventListener('mousemove', handleLaserMove);
                stopLaserSound();
                drawFractal();
            }
        });

        fractalCanvas.addEventListener('mouseleave', () => {
             if (currentMode === 'fractal' && isDrawingLaser) {
                 isDrawingLaser = false;
                 fractalCanvas.removeEventListener('mousemove', handleLaserMove);
                 stopLaserSound();
                 drawFractal();
             }
         });


        generateButton.addEventListener('click', handleGenerateButtonClick);
        clearAllButton.addEventListener('click', clearAll);
        settingsButton.addEventListener('click', () => settingsModal.classList.remove('hidden'));
        closeSettingsModalButton.addEventListener('click', () => settingsModal.classList.add('hidden'));

        // Sound settings checkbox listener
        enableSoundsCheckbox.addEventListener('change', () => {
            soundsEnabled = enableSoundsCheckbox.checked;
            saveSoundSetting(soundsEnabled);
        });

        // --- Drag and Drop Logic (Unified for DNA/Material) ---
        document.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('dna-component') || e.target.classList.contains('material-component')) {
                currentDraggedElement = e.target.cloneNode(true);
                if (e.target.classList.contains('dna-component')) {
                    currentDraggedElement.classList.add('dna-component-dragged');
                } else {
                    currentDraggedElement.classList.add('material-component-dragged');
                }
                document.body.appendChild(currentDraggedElement);

                dragOffsetX = e.clientX - e.target.getBoundingClientRect().left;
                dragOffsetY = e.clientY - e.target.getBoundingClientRect().top;
                currentDraggedElement.style.left = `${e.clientX - dragOffsetX}px`;
                currentDraggedElement.style.top = `${e.clientY - dragOffsetY}px`;

                e.dataTransfer.setDragImage(new Image(), 0, 0);
                playClickSound();
            }
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (currentDraggedElement) {
                currentDraggedElement.style.left = `${e.clientX - dragOffsetX}px`;
                currentDraggedElement.style.top = `${e.clientY - dragOffsetY}px`;
            }
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            if (currentDraggedElement) {
                const droppedComponent = currentDraggedElement.getAttribute('data-component');
                if (droppedComponent) {
                    let targetDropzoneElement;
                    if (currentMode === 'material' && currentMaterialInputMode === 'drag_drop') {
                        targetDropzoneElement = materialCompositionContent;
                    } else if (currentMode === 'trait' || currentMode === 'dna_bases') {
                        targetDropzoneElement = dnaStrandDropzone;
                    } else {
                        return;
                    }

                    const dropzoneRect = targetDropzoneElement.getBoundingClientRect();
                    if (e.clientX > dropzoneRect.left && e.clientX < dropzoneRect.right &&
                        e.clientY > dropzoneRect.top && e.clientY < dropzoneRect.bottom) {

                        if (currentMode === 'material' && currentMaterialInputMode === 'drag_drop') {
                            addMaterialComponentToComposition(droppedComponent);
                        } else if (currentMode === 'trait' || currentMode === 'dna_bases') {
                            addDnaTraitToSequence(droppedComponent);
                        }
                        playDropSound();
                    }
                }
            }
        });

        document.addEventListener('dragend', () => {
            if (currentDraggedElement && currentDraggedElement.parentNode) {
                currentDraggedElement.parentNode.removeChild(currentDraggedElement);
                currentDraggedElement = null;
            }
        });

        // Event listener for clicking on items in the dropzone to remove them (for DNA and Material D&D)
        dnaStrandDropzone.addEventListener('click', (e) => {
            if ((currentMode === 'trait' || currentMode === 'dna_bases') && e.target.classList.contains('dna-strand-item')) {
                const indexToRemove = parseInt(e.target.getAttribute('data-index'));
                dnaSequence.splice(indexToRemove, 1);
                updateDnaStrandDisplay();
                playRemoveSound();
            }
        });

        materialCompositionContent.addEventListener('click', (e) => {
            if ((currentMode === 'material' && currentMaterialInputMode === 'drag_drop') && e.target.classList.contains('material-composition-item')) {
                const indexToRemove = parseInt(e.target.getAttribute('data-index'));
                materialComposition.splice(indexToRemove, 1);
                updateMaterialCompositionDisplay();
                playRemoveSound();
            }
        });


        // Preset Buttons
        document.getElementById('preset-human').addEventListener('click', () => loadPreset('humanoid'));
        document.getElementById('preset-aquatic').addEventListener('click', () => loadPreset('aquatic'));
        document.getElementById('preset-avian').addEventListener('click', () => loadPreset('avian'));
        document.getElementById('preset-reptilian').addEventListener('click', () => loadPreset('reptilian'));

        // --- Mode & Palette Management ---

        function setMode(mode) {
            if (currentMode === mode) return;

            currentMode = mode;
            clearAll(); // Clear current content when switching modes

            // Update active mode button styling
            traitModeButton.classList.toggle('active', mode === 'trait');
            dnaModeButton.classList.toggle('active', mode === 'dna_bases');
            materialModeButton.classList.toggle('active', mode === 'material');
            mathModeButton.classList.toggle('active', mode === 'math');
            fractalModeButton.classList.toggle('active', mode === 'fractal');

            // Toggle left panel controls visibility
            creatureControls.classList.toggle('hidden', mode !== 'trait' && mode !== 'dna_bases');
            materialControls.classList.toggle('hidden', mode !== 'material');
            mathControls.classList.toggle('hidden', mode !== 'math');
            fractalControls.classList.toggle('hidden', mode !== 'fractal');

            // Toggle main content display areas visibility
            creatureDisplayArea.classList.toggle('hidden', mode !== 'trait' && mode !== 'dna_bases');
            materialOutputArea.classList.toggle('hidden', mode !== 'material');
            mathDisplayArea.classList.toggle('hidden', mode !== 'math');
            fractalDisplayArea.classList.toggle('hidden', mode !== 'fractal');

            // Update main title
            mainTitle.textContent = (mode === 'material') ? 'Material Synthesizer' :
                                    (mode === 'math' ? 'Math & Shape Generator' :
                                    (mode === 'fractal' ? 'Fractal Explorer' : 'Creature Synthesizer'));

            // Special handling for each mode
            if (mode === 'material') {
                presetButtonsContainer.classList.add('hidden');
                materialInputManualRadio.checked = (currentMaterialInputMode === 'manual');
                materialInputDragDropRadio.checked = (currentMaterialInputMode === 'drag_drop');
                setMaterialInputMode(currentMaterialInputMode);
            } else if (mode === 'math') {
                presetButtonsContainer.classList.add('hidden');
                mathResultOutput.innerHTML = '<p class="text-lg text-purple-400">Calculation result will appear here.</p>';
                mathDescriptionOutput.innerHTML = '<p class="text-lg text-purple-400">Shape description and properties will appear here.</p>';
                ctxShape.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
            } else if (mode === 'fractal') {
                presetButtonsContainer.classList.add('hidden');
                fractalTypeSelect.value = 'mandelbrot';
                juliaParamsDiv.classList.add('hidden');
                juliaCxInput.value = '-0.70176';
                juliaCyInput.value = '-0.3842';
                maxIterationsInput.value = '100';
                xMin = -2.5; xMax = 1.5; yMin = -1.5; yMax = 1.5;
                fractalDescriptionOutput.innerHTML = '<p class="text-lg text-purple-400">AI descriptions of 4D rotations will appear here.</p>';
                updateFractalCoordsDisplay();
                drawFractal();
            }
            else { // Creature modes (trait or dna_bases)
                presetButtonsContainer.classList.remove('hidden');
                populateDnaPalette();
                dnaStrandDropzone.innerHTML = '<p class="text-lg text-purple-400">Drag DNA components here to build your creature\'s genetic code.</p>';
            }

            showMessageBox(`Switched to ${mainTitle.textContent}.`);
        }

        function setMaterialInputMode(mode) {
            currentMaterialInputMode = mode;
            manualMaterialInputsDiv.classList.toggle('hidden', mode === 'drag_drop');
            materialDragPalette.classList.toggle('hidden', mode === 'manual');
            // Control visibility of the material dropzone outer div
            materialCompositionDropzoneOuter.classList.toggle('hidden', mode === 'manual');

            if (mode === 'drag_drop') {
                populateMaterialDragPalette();
                updateMaterialCompositionDisplay();
            } else {
                materialComposition = [];
            }
        }

        function populateDnaPalette() {
            dnaComponentsPalette.innerHTML = '';
            const componentsToDisplay = (currentMode === 'trait') ? traitComponents : dnaBaseComponents;
            componentsToDisplay.forEach(component => {
                const div = document.createElement('div');
                div.classList.add('dna-component');
                div.textContent = component;
                div.setAttribute('data-component', component);
                div.draggable = true;
                dnaComponentsPalette.appendChild(div);
            });
        }

        function populateMaterialDragPalette() {
            materialDragPalette.innerHTML = '';
            materialComponents.forEach(component => {
                const div = document.createElement('div');
                div.classList.add('material-component');
                div.textContent = component;
                div.setAttribute('data-component', component);
                div.draggable = true;
                materialDragPalette.appendChild(div);
            });
        }

        // --- DNA/Creature Specific Functions ---
        function addDnaTraitToSequence(trait) {
            dnaSequence.push(trait);
            updateDnaStrandDisplay();
        }

        function updateDnaStrandDisplay() {
            dnaStrandDropzone.innerHTML = '';
            if (dnaSequence.length === 0) {
                dnaStrandDropzone.innerHTML = '<p class="text-lg text-purple-400">Drag DNA components here to build your creature\'s genetic code.</p>';
            } else {
                dnaSequence.forEach((trait, index) => {
                    const div = document.createElement('div');
                    div.classList.add('dna-strand-item');
                    div.textContent = trait;
                    div.setAttribute('data-index', index);
                    dnaStrandDropzone.appendChild(div);
                });
            }
        }

        // --- Material Specific Functions ---
        function addMaterialComponentToComposition(component) {
            materialComposition.push(component);
            updateMaterialCompositionDisplay();
            console.log("Current Material Composition:", materialComposition);
        }

        function updateMaterialCompositionDisplay() {
            materialCompositionContent.innerHTML = '';
            if (materialComposition.length === 0) {
                materialCompositionContent.innerHTML = '<p class="text-lg text-purple-400">Drag material components here to build your material.</p>';
            } else {
                materialComposition.forEach((component, index) => {
                    const div = document.createElement('div');
                    div.classList.add('material-composition-item');
                    div.textContent = component;
                    div.setAttribute('data-index', index);
                    materialCompositionContent.appendChild(div);
                });
            }
        }

        // --- Clear All Functionality ---
        function clearAll() {
            if (currentMode === 'material') {
                materialNameInput.value = '';
                materialStateSelect.value = 'solid';
                materialPropertiesTextarea.value = '';
                materialChemistryTextarea.value = '';
                materialUseTextarea.value = '';
                materialComposition = [];
                updateMaterialCompositionDisplay();
                materialDescriptionOutput.innerHTML = '<p class="text-lg text-purple-400">Your material description will appear here.</p>';
                materialImage.src = '';
                materialImage.style.display = 'none';
                materialImagePlaceholder.style.display = 'block';
                materialImagePlaceholder.textContent = 'Your material image will appear here.';
                showMessageBox("Material inputs and outputs cleared!");
            } else if (currentMode === 'math') {
                mathExpressionInput.value = '';
                shapeTypeInput.value = '';
                shapeNumberInput.value = '';
                mathResultOutput.innerHTML = '<p class="text-lg text-purple-400">Calculation result will appear here.</p>';
                mathDescriptionOutput.innerHTML = '<p class="text-lg text-purple-400">Shape description and properties will appear here.</p>';
                ctxShape.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
                showMessageBox("Math inputs and outputs cleared!");
            } else if (currentMode === 'fractal') {
                xMin = -2.5; xMax = 1.5; yMin = -1.5; yMax = 1.5;
                fractalTypeSelect.value = 'mandelbrot';
                juliaParamsDiv.classList.add('hidden');
                juliaCxInput.value = '-0.70176';
                juliaCyInput.value = '-0.3842';
                maxIterationsInput.value = '100';
                updateFractalCoordsDisplay();
                drawFractal();
                fractalDescriptionOutput.innerHTML = '<p class="text-lg text-purple-400">AI descriptions of 4D rotations will appear here.</p>';
                showMessageBox("Fractal view reset!");
            }
            else { // Trait or DNA Base Mode
                dnaSequence = [];
                updateDnaStrandDisplay();
                creatureImage.src = '';
                creatureImage.style.display = 'none';
                imagePlaceholder.style.display = 'block';
                imagePlaceholder.textContent = 'Your creature will appear here!';
                showMessageBox("DNA strand and creature display cleared!");
            }
        }

        // --- Unified Generate Logic ---
        async function handleGenerateButtonClick() {
            if (currentMode === 'material') {
                await generateMaterialDescriptionAndImageFlow();
            } else if (currentMode === 'math') {
                await handleMathCalculation();
            } else if (currentMode === 'fractal') {
                drawFractal();
                showMessageBox("Fractal re-rendered!");
            }
            else { // Creature modes
                await generateCreatureTextAndImage();
            }
        }

        // --- Creature Generation Flow ---
        async function generateCreatureTextAndImage() {
            if (dnaSequence.length === 0) {
                showMessageBox("Please drag some DNA components to the strand first!");
                return;
            }

            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Generating creature description...';
            let textPrompt = "";

            if (currentMode === 'trait') {
                let eyeCount = dnaSequence.find(trait => trait.startsWith('Eyes ('));
                let legCount = dnaSequence.find(trait => trait.startsWith('Legs ('));
                let armCount = dnaSequence.find(trait => trait.startsWith('Arms ('));

                let remainingTraits = dnaSequence.filter(trait =>
                    !trait.startsWith('Eyes (') && !trait.startsWith('Legs (') && !trait.startsWith('Arms (')
                );

                textPrompt = `Based on these genetic traits: [${remainingTraits.join(', ')}], describe a unique and fantastical creature. `;

                if (eyeCount) {
                    textPrompt += `It has ${eyeCount.replace('Eyes (', '').replace(')', '')} eyes. `;
                } else if (remainingTraits.includes('Large Eyes')) {
                    textPrompt += `It has prominent large eyes. `;
                } else if (remainingTraits.includes('Small Eyes')) {
                    textPrompt += `It has small eyes. `;
                } else if (remainingTraits.includes('Compound Eyes')) {
                    textPrompt += `It has compound eyes. `;
                } else if (remainingTraits.includes('No Eyes')) {
                    textPrompt += `It has no visible eyes. `;
                }

                if (legCount) {
                    textPrompt += `It has ${legCount.replace('Legs (', '').replace(')', '')} legs. `;
                } else if (remainingTraits.includes('Bipedal')) {
                    textPrompt += `It is bipedal. `;
                } else if (remainingTraits.includes('Quadrupedal')) {
                    textPrompt += `It is quadrupedal. `;
                } else if (remainingTraits.includes('Hexapodal')) {
                    textPrompt += `It is hexapodal. `;
                } else if (remainingTraits.includes('No Legs')) {
                    textPrompt += `It has no legs. `;
                }

                if (armCount) {
                    textPrompt += `It has ${armCount.replace('Arms (', '').replace(')', '')} arms. `;
                } else if (remainingTraits.includes('No Arms')) {
                    textPrompt += `It has no arms. `;
                }

                textPrompt += `Focus on its appearance (body shape, color, texture), primary characteristics (e.g., how it moves, what it eats), and general form. Do not mention specific Earth animals unless directly implied by traits. Keep the description concise and creative, allowing for bizarre or unexpected combinations.`;

            } else { // currentMode === 'dna_bases'
                textPrompt = `Imagine a fantastical creature whose genetic structure is represented by the following simplified sequence of DNA base pairs and components: [${dnaSequence.join(', ')}]. Creatively interpret this abstract genetic code. Describe the creature's appearance, its unique biological functions, and how these might relate to the provided 'DNA' elements. Make it truly original and perhaps a bit bizarre, avoiding direct mimicry of real-world organisms.`;
            }

            let aiDescription = "";
            try {
                // Step 1: Generate Textual Description
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: textPrompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Text API error (Description): ${response.status} - ${errorData.error.message}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    aiDescription = result.candidates[0].content.parts[0].text;
                    console.log("AI Description:", aiDescription);
                } else {
                    showMessageBox("Failed to generate creature description. Try again.");
                    console.error("Unexpected AI text response structure for description:", result);
                    loadingIndicator.style.display = 'none';
                    return;
                }
            } catch (error) {
                showMessageBox(`Error describing creature: ${error.message}. Check console for details.`);
                console.error("Error calling Gemini text API for description:", error);
                loadingIndicator.style.display = 'none';
                return;
            }

            // Step 2: Generate Image based on the description
            loadingIndicator.textContent = 'Generating creature image...';
            creatureImage.style.display = 'none';
            imagePlaceholder.style.display = 'block';
            imagePlaceholder.textContent = 'Generating image...';

            const imagePrompt = `Generate a highly detailed, fantastical creature image based on this description: "${aiDescription}". The creature should be set against a simple, ethereal background. Focus on realistic textures, lighting, and a unique, imaginative design.`;

            try {
                const payload = { instances: { prompt: imagePrompt }, parameters: { "sampleCount": 1} };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Image API error: ${response.status} - ${errorData.error.message}`);
                }

                const result = await response.json();
                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                    creatureImage.src = imageUrl;
                    creatureImage.style.display = 'block';
                    imagePlaceholder.style.display = 'none';
                    showMessageBox("Creature image generated!");
                    playGenerateSuccessSound();
                } else {
                    showMessageBox("Failed to generate creature image. Try again.");
                    console.error("Unexpected AI image response structure:", result);
                    imagePlaceholder.textContent = 'Failed to generate image.';
                }
            } catch (error) {
                showMessageBox(`Error generating image: ${error.message}. Check console for details.`);
                console.error("Error calling Imagen API:", error);
                imagePlaceholder.textContent = `Error: ${error.message.substring(0, 50)}...`;
            } finally {
                loadingIndicator.style.display = 'none';
            }

            // Save the generated creature to Firestore
            saveGeneratedItem(dnaSequence, aiDescription, currentMode, null);
        }

        // --- Material Generation Flow (Description AND Image) ---
        async function generateMaterialDescriptionAndImageFlow() {
            const inputContent = currentMaterialInputMode === 'manual' ? {
                name: materialNameInput.value.trim(),
                state: materialStateSelect.value,
                properties: materialPropertiesTextarea.value.trim(),
                chemistry: materialChemistryTextarea.value.trim(),
                use: materialUseTextarea.value.trim()
            } : materialComposition.slice();

            if (currentMaterialInputMode === 'manual' && !inputContent.name && !inputContent.properties && !inputContent.chemistry && !inputContent.use) {
                showMessageBox("Please provide some details for the material!");
                return;
            }
            if (currentMaterialInputMode === 'drag_drop' && inputContent.length === 0) {
                 showMessageBox("Please drag some material components to the dropzone!");
                 return;
            }

            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Generating material description...';
            materialDescriptionOutput.innerHTML = '<p class="text-lg text-purple-400">Generating material description...</p>';
            materialImage.style.display = 'none';
            materialImagePlaceholder.style.display = 'block';
            materialImagePlaceholder.textContent = 'Generating image...';


            let materialPrompt = "Generate a detailed description for a fantastical, futuristic, or unique material.";
            if (currentMaterialInputMode === 'manual') {
                if (inputContent.name) materialPrompt += ` Its name is '${inputContent.name}'.`;
                materialPrompt += ` It is in a ${inputContent.state} state.`;
                if (inputContent.properties) materialPrompt += ` Key properties include: ${inputContent.properties}.`;
                if (inputContent.chemistry) materialPrompt += ` Its chemistry or composition involves: ${inputContent.chemistry}.`;
                if (inputContent.use) materialPrompt += ` It is primarily intended for: ${inputContent.use}.`;
            } else { // drag_drop
                materialPrompt += ` Its composition is based on these components: [${inputContent.join(', ')}].`;
                materialPrompt += ` Elaborate on how these components combine to form a unique material, interpreting any non-material components creatively (e.g., how a 'Legs (2)' trait might influence a material's movement or structure).`;
            }
            materialPrompt += ` Focus on its appearance, feel, unique abilities, and scientific principles (even if fictional).`;


            let materialDescription = "";
            try {
                // Step 1: Generate Material Description
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: materialPrompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Text API error (Description): ${response.status} - ${errorData.error.message}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    materialDescription = result.candidates[0].content.parts[0].text;
                    materialDescriptionOutput.textContent = materialDescription;
                } else {
                    showMessageBox("Failed to generate material description. Try again.");
                    console.error("Unexpected AI text response structure for description:", result);
                    loadingIndicator.style.display = 'none';
                    return;
                }
            } catch (error) {
                showMessageBox(`Error describing material: ${error.message}. Check console for details.`);
                console.error("Error calling Gemini text API for description:", error);
                loadingIndicator.style.display = 'none';
                return;
            }

            // Step 2: Generate Material Image based on the description
            loadingIndicator.textContent = 'Generating material image...';
            const imagePrompt = `Generate a highly detailed, realistic, and fantastical image of the following material: "${materialDescription}". The image should showcase its key properties and a unique visual appearance. Use a clean, studio-like background that highlights the material itself.`;

            let imageUrl = null;
            try {
                const payload = { instances: { prompt: imagePrompt }, parameters: { "sampleCount": 1} };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Image API error: ${response.status} - ${errorData.error.message}`);
                }

                const result = await response.json();
                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                    materialImage.src = imageUrl;
                    materialImage.style.display = 'block';
                    materialImagePlaceholder.style.display = 'none';
                    showMessageBox("Material image generated!");
                    playGenerateSuccessSound();
                } else {
                    showMessageBox("Failed to generate material image. Try again.");
                    console.error("Unexpected AI image response structure:", result);
                    materialImagePlaceholder.textContent = 'Failed to generate image.';
                }
            } catch (error) {
                showMessageBox(`Error generating material image: ${error.message}. Check console for details.`);
                console.error("Error calling Imagen API for material image:", error);
                materialImagePlaceholder.textContent = `Error: ${error.message.substring(0, 50)}...`;
            } finally {
                loadingIndicator.style.display = 'none';
            }

            // Save the generated material (description and image URL) to Firestore
            saveGeneratedItem(inputContent, materialDescription, currentMode, imageUrl);
        }

        // --- Math Mode Functions ---
        async function handleMathCalculation() {
            const expression = mathExpressionInput.value.trim();
            const shapeType = shapeTypeInput.value.trim().toLowerCase();
            const shapeNumberStr = shapeNumberInput.value.trim();

            if (!expression && !shapeType) {
                showMessageBox("Please enter a math expression or a shape to generate!");
                return;
            }

            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Performing calculations...';
            mathResultOutput.innerHTML = '<p class="text-lg text-purple-400">Calculating...</p>';
            mathDescriptionOutput.innerHTML = '<p class="text-lg text-purple-400">Generating shape description...</p>';
            ctxShape.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);

            let calculationResult = "N/A";
            let parsedShapeNumbers = [];

            // Helper function to check for balanced parentheses
            function isParenthesesBalanced(exp) {
                let balance = 0;
                for (let i = 0; i < exp.length; i++) {
                    const char = exp[i];
                    if (char === '(') {
                        balance++;
                    } else if (char === ')') {
                        balance--;
                    }
                    if (balance < 0) {
                        return false;
                    }
                }
                return balance === 0;
            }

            // 1. Perform Math Calculation (simple parser)
            if (expression) {
                try {
                    let safeExpression = expression.replace(/[^0-9+\-*/().\s^]/g, '');
                    safeExpression = safeExpression.replace(/\^/g, '**');

                    safeExpression = safeExpression.replace(/sqrt\(([^)]+)\)/g, 'Math.sqrt($1)');
                    safeExpression = safeExpression.replace(/log\(([^)]+)\)/g, 'Math.log($1)');
                    safeExpression = safeExpression.replace(/sin\(([^)]+)\)/g, 'Math.sin($1)');
                    safeExpression = safeExpression.replace(/cos\(([^)]+)\)/g, 'Math.cos($1)');
                    safeExpression = safeExpression.replace(/tan\(([^)]+)\)/g, 'Math.tan($1)');

                    if (!isParenthesesBalanced(safeExpression)) {
                        throw new Error("Unbalanced parentheses in expression.");
                    }

                    calculationResult = Function(`'use strict'; return (${safeExpression})`)();
                    mathResultOutput.textContent = `Result: ${calculationResult}`;
                } catch (e) {
                    mathResultOutput.textContent = `Error: ${e.message}`;
                    showMessageBox(`Math expression error: ${e.message}`);
                    console.error("Math expression evaluation error:", e);
                    loadingIndicator.style.display = 'none';
                    return;
                }
            }

            // 2. Parse Shape Numbers
            if (shapeNumberStr) {
                parsedShapeNumbers = shapeNumberStr.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
                if (parsedShapeNumbers.some(isNaN) || parsedShapeNumbers.length === 0) {
                    showMessageBox("Invalid shape number(s). Please enter numbers separated by commas (e.g., '5' or '6,4').");
                    loadingIndicator.style.display = 'none';
                    return;
                }
            }

            // 3. Draw Shape on Canvas
            drawShape(shapeType, parsedShapeNumbers);

            // 4. Generate AI Description for Math & Shape
            loadingIndicator.textContent = 'Generating shape description...';
            let mathDescriptionPrompt = `Based on the following inputs: `;
            if (expression) {
                mathDescriptionPrompt += `Mathematical expression "${expression}" which resulted in "${calculationResult}". `;
            }
            if (shapeType) {
                mathDescriptionPrompt += `A ${shapeType} shape was requested with parameter(s) ${shapeNumberStr}.`;
            }
            mathDescriptionPrompt += ` Provide a clear explanation of the numerical result (if any). Describe the geometric properties of the ${shapeType || 'shape'} based on the given number(s), calculate its area and perimeter (if applicable and possible with the given parameters), and describe its visual characteristics. Keep it concise and informative.`;


            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: mathDescriptionPrompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Text API error (Math Description): ${response.status} - ${errorData.error.message}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const aiDescription = result.candidates[0].content.parts[0].text;
                    mathDescriptionOutput.textContent = aiDescription;
                    showMessageBox("Math calculation and shape generated!");
                    playGenerateSuccessSound();
                } else {
                    showMessageBox("Failed to generate math description. Try again.");
                    console.error("Unexpected AI text response structure for math description:", result);
                }
            } catch (error) {
                showMessageBox(`Error generating math description: ${error.message}. Check console for details.`);
                console.error("Error calling Gemini text API for math description:", error);
            } finally {
                loadingIndicator.style.display = 'none';
            }

            // Save math generation to Firestore
            saveGeneratedItem({ expression, shapeType, shapeNumberStr, calculationResult }, null, currentMode, null);
        }

        function drawShape(type, params) {
            const canvasSize = 250;
            shapeCanvas.width = canvasSize;
            shapeCanvas.height = canvasSize;
            ctxShape.clearRect(0, 0, canvasSize, canvasSize);

            ctxShape.strokeStyle = '#a64ac9';
            ctxShape.lineWidth = 3;
            ctxShape.fillStyle = '#7f38d3';

            const centerX = canvasSize / 2;
            const centerY = canvasSize / 2;

            if (type === 'square') {
                const side = params[0] || 50;
                const x = centerX - side / 2;
                const y = centerY - side / 2;
                ctxShape.fillRect(x, y, side, side);
                ctxShape.strokeRect(x, y, side, side);
            } else if (type === 'circle') {
                const radius = params[0] || 50;
                ctxShape.beginPath();
                ctxShape.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctxShape.fill();
                ctxShape.stroke();
            } else if (type === 'triangle') {
                const base = params[0] || 100;
                const height = params[1] || 80;
                ctxShape.beginPath();
                ctxShape.moveTo(centerX, centerY - height / 2);
                ctxShape.lineTo(centerX - base / 2, centerY + height / 2);
                ctxShape.lineTo(centerX + base / 2, centerY + height / 2);
                ctxShape.closePath();
                ctxShape.fill();
                ctxShape.stroke();
            } else if (type === 'rectangle') {
                const width = params[0] || 100;
                const height = params[1] || 60;
                const x = centerX - width / 2;
                const y = centerY - height / 2;
                ctxShape.fillRect(x, y, width, height);
                ctxShape.strokeRect(x, y, width, height);
            } else {
                ctxShape.font = '16px Inter';
                ctxShape.fillStyle = '#e0e0e0';
                ctxShape.textAlign = 'center';
                ctxShape.fillText('Shape not recognized', centerX, centerY);
            }
        }

        // --- Fractal Mode Functions ---

        function updateFractalCoordsDisplay() {
            fractalXminDisplay.textContent = xMin.toFixed(5);
            fractalXmaxDisplay.textContent = xMax.toFixed(5);
            fractalYminDisplay.textContent = yMin.toFixed(5);
            fractalYmaxDisplay.textContent = yMax.toFixed(5);
        }

        function drawFractal() {
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Rendering fractal...';

            const canvasWidth = fractalCanvas.clientWidth;
            const canvasHeight = fractalCanvas.clientHeight;
            fractalCanvas.width = canvasWidth;
            fractalCanvas.height = canvasHeight;
            ctxFractal.clearRect(0, 0, canvasWidth, canvasHeight);

            const type = fractalTypeSelect.value;
            const maxIterations = parseInt(maxIterationsInput.value) || 100;
            const juliaCx = parseFloat(juliaCxInput.value) || 0;
            const juliaCy = parseFloat(juliaCyInput.value) || 0;

            const xRange = xMax - xMin;
            const yRange = yMax - yMin;

            const iterationGrid = [];
            for (let y = 0; y < canvasHeight; y++) {
                iterationGrid[y] = [];
                for (let x = 0; x < canvasWidth; x++) {
                    let real = xMin + (x / canvasWidth) * xRange;
                    let imag = yMin + (y / canvasHeight) * yRange;

                    let zr = 0;
                    let zi = 0;
                    let iter = 0;

                    let cr, ci;
                    if (type === 'mandelbrot') {
                        cr = real;
                        ci = imag;
                    } else {
                        cr = juliaCx;
                        ci = juliaCy;
                        zr = real;
                        zi = imag;
                    }

                    while (zr * zr + zi * zi < 4 && iter < maxIterations) {
                        let tempZr = zr * zr - zi * zi + cr;
                        zi = 2 * zr * zi + ci;
                        zr = tempZr;
                        iter++;
                    }

                    let color;
                    if (iter === maxIterations) {
                        color = 'black';
                    } else {
                        let logZn = Math.log(zr * zr + zi * zi) / 2;
                        let nu = Math.log(logZn / Math.log(2)) / Math.log(2);
                        iter = iter + 1 - nu;

                        const color1 = [0, 7, 100];
                        const color2 = [32, 107, 203];
                        const color3 = [237, 255, 255];

                        let t = iter / maxIterations;
                        let r, g, b;

                        if (t < 0.5) {
                            t = t * 2;
                            r = color1[0] * (1 - t) + color2[0] * t;
                            g = color1[1] * (1 - t) + color2[1] * t;
                            b = color1[2] * (1 - t) + color2[2] * t;
                        } else {
                            t = (t - 0.5) * 2;
                            r = color2[0] * (1 - t) + color3[0] * t;
                            g = color2[1] * (1 - t) + color3[1] * t;
                            b = color2[2] * (1 - t) + color3[2] * t;
                        }
                        color = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
                    }
                    ctxFractal.fillStyle = color;
                    ctxFractal.fillRect(x, y, 1, 1);
                    iterationGrid[y][x] = iter;
                }
            }
            loadingIndicator.style.display = 'none';
            playGenerateSuccessSound();
            saveGeneratedItem({ type, xMin, xMax, yMin, yMax, maxIterations, juliaCx, juliaCy }, "Fractal rendered", currentMode, null);
            return iterationGrid;
        }

        let currentIterationGrid = null;

        const originalDrawFractal = drawFractal;
        drawFractal = function() {
            currentIterationGrid = originalDrawFractal();
        };

        function zoomFractal(direction) {
            const centerX = (xMin + xMax) / 2;
            const centerY = (yMin + yMax) / 2;
            const width = xMax - xMin;
            const height = yMax - yMin;

            if (direction === 1) {
                xMin = centerX - (width * zoomFactor) / 2;
                xMax = centerX + (width * zoomFactor) / 2;
                yMin = centerY - (height * zoomFactor) / 2;
                yMax = centerY + (height * zoomFactor) / 2;
            } else {
                xMin = centerX - (width / zoomFactor) / 2;
                xMax = centerX + (width / zoomFactor) / 2;
                yMin = centerY - (height / zoomFactor) / 2;
                yMax = centerY + (height / zoomFactor) / 2;
            }
            updateFractalCoordsDisplay();
            drawFractal();
        }

        async function generate4DRotationDescription(axis) {
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = `Imagining 4D rotation along ${axis}-axis...`;
            fractalDescriptionOutput.innerHTML = '<p class="text-lg text-purple-400">Generating 4D rotation description...</p>';

            const fractalType = fractalTypeSelect.value;
            const currentXMin = fractalXminDisplay.textContent;
            const currentXMax = fractalXmaxDisplay.textContent;
            const currentYMin = fractalYminDisplay.textContent;
            const currentYMax = fractalYmaxDisplay.textContent;
            const maxIterations = maxIterationsInput.value;
            const juliaCx = juliaCxInput.value;
            const juliaCy = juliaCyInput.value;

            let prompt = `Imagine a ${fractalType} fractal existing in 4 dimensions. Describe what a small rotation along its ${axis}-axis might look like when projected back into 2D, keeping in mind its current 2D view complex plane ranges from X: ${currentXMin} to ${currentXMax} and Y: ${currentYMin} to ${currentYMax}. Focus on changes in shape, distortion, new patterns emerging, or how existing patterns might warp. Be creative and concise.`;
            if (fractalType === 'julia') {
                prompt += ` The Julia set constant C is (${juliaCx}, ${juliaCy}).`;
            }

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Text API error (4D Rotation): ${response.status} - ${errorData.error.message}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const description = result.candidates[0].content.parts[0].text;
                    fractalDescriptionOutput.textContent = description;
                    showMessageBox(`4D rotation along ${axis}-axis described.`);
                    saveGeneratedItem({ fractalType, rotationAxis: axis, description }, description, currentMode, null);
                } else {
                    showMessageBox("Failed to generate 4D rotation description. Try again.");
                    console.error("Unexpected AI text response structure for 4D rotation:", result);
                }
            } catch (error) {
                showMessageBox(`Error describing 4D rotation: ${error.message}. Check console for details.`);
                console.error("Error calling Gemini text API for 4D rotation:", error);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function handleLaserMove(e) {
            if (!isDrawingLaser || !currentIterationGrid) return;

            const rect = fractalCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const laserOriginX = 0;
            const laserOriginY = fractalCanvas.height;

            drawFractal();
            ctxFractal.beginPath();
            ctxFractal.moveTo(laserOriginX, laserOriginY);
            ctxFractal.lineTo(mouseX, mouseY);
            ctxFractal.strokeStyle = 'red';
            ctxFractal.lineWidth = 2;
            ctxFractal.stroke();

            let maxIter = 0;
            const numSteps = Math.max(Math.abs(mouseX - laserOriginX), Math.abs(mouseY - laserOriginY));
            for (let i = 0; i <= numSteps; i++) {
                const px = Math.floor(laserOriginX + (mouseX - laserOriginX) * (i / numSteps));
                const py = Math.floor(laserOriginY + (mouseY - laserOriginY) * (i / numSteps));

                if (px >= 0 && px < fractalCanvas.width && py >= 0 && py < fractalCanvas.height) {
                    const iter = currentIterationGrid[py][px];
                    if (iter > maxIter) {
                        maxIter = iter;
                    }
                }
            }

            const minFreq = 100;
            const maxFreq = 800;
            const normalizedIter = maxIter / parseInt(maxIterationsInput.value);
            const frequency = minFreq + (maxFreq - minFreq) * normalizedIter;

            if (maxIter > 0) {
                playLaserSound(frequency);
            } else {
                stopLaserSound();
            }
        }


        // --- Firestore Saving and Loading ---
        const settingsDocRef = (uid) => doc(db, `artifacts/${appId}/users/${uid}/settings/userPreferences`);

        async function saveSoundSetting(enabled) {
            if (!userId) {
                console.warn("User ID not available, cannot save sound setting.");
                return;
            }
            try {
                await setDoc(settingsDocRef(userId), { soundEnabled: enabled }, { merge: true });
                console.log("Sound setting saved:", enabled);
            } catch (e) {
                console.error("Error saving sound setting:", e);
            }
        }

        async function loadSoundSetting() {
            if (!userId) {
                console.warn("User ID not available, cannot load sound setting.");
                return;
            }
            try {
                const docSnap = await getDoc(settingsDocRef(userId));
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (typeof data.soundEnabled === 'boolean') {
                        soundsEnabled = data.soundEnabled;
                        enableSoundsCheckbox.checked = soundsEnabled;
                        console.log("Sound setting loaded:", soundsEnabled);
                    }
                } else {
                    // No existing setting, save default
                    await saveSoundSetting(soundsEnabled);
                }
            } catch (e) {
                console.error("Error loading sound setting:", e);
            }
        }


        async function saveGeneratedItem(inputData, description, mode, imageUrl = null) {
            if (!userId) {
                console.warn("User ID not available for saving item.");
                return;
            }

            try {
                const collectionPath = `artifacts/${appId}/users/${userId}/${mode}Generations`;
                const docData = {
                    mode: mode,
                    description: description,
                    timestamp: serverTimestamp(),
                    userId: userId
                };

                if (mode === 'material') {
                    if (currentMaterialInputMode === 'manual') {
                        docData.materialName = inputData.name;
                        docData.materialState = inputData.state;
                        docData.materialProperties = inputData.properties;
                        docData.materialChemistry = inputData.chemistry;
                        docData.materialUse = inputData.use;
                    } else { // drag_drop
                        docData.materialComposition = inputData;
                    }
                    docData.imageUrl = imageUrl;
                } else if (mode === 'math') {
                    docData.mathExpression = inputData.expression;
                    docData.calculationResult = inputData.calculationResult;
                    docData.shapeType = inputData.shapeType;
                    docData.shapeNumberStr = inputData.shapeNumberStr;
                } else if (mode === 'fractal') {
                    docData.fractalType = inputData.type;
                    docData.xMin = inputData.xMin;
                    docData.xMax = inputData.xMax;
                    docData.yMin = inputData.yMin;
                    docData.yMax = inputData.yMax;
                    docData.maxIterations = inputData.maxIterations;
                    if (inputData.type === 'julia') {
                        docData.juliaCx = inputData.juliaCx;
                        docData.juliaCy = inputData.juliaCy;
                    }
                    if (inputData.rotationAxis) {
                        docData.rotationAxis = inputData.rotationAxis;
                        docData.rotationDescription = description;
                    } else {
                        docData.description = description;
                    }
                }
                else { // Trait or DNA Base Mode
                    docData.dnaSequence = inputData;
                    docData.imageUrl = imageUrl;
                }

                await addDoc(collection(db, collectionPath), docData);
                console.log(`${mode} generation saved to Firestore!`);
            } catch (e) {
                console.error(`Error saving ${mode} generation to Firestore: `, e);
                showMessageBox(`Failed to save ${mode} generation. Check console for details.`);
            }
        }

        // --- Initial Setup ---
        window.onload = function () {
            setMode('trait');
        }

    </script>
</body>
</html>
