<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ðŸ”¥ ULTIMATE GPU LAG ðŸ”¥</title>
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; height:100%; background:black;
  }
  #warning {
    position:absolute; top:50%; left:50%;
    transform: translate(-50%, -50%);
    font-family: monospace;
    font-size: 8em;
    color: white;
    text-shadow: 0 0 15px red, 0 0 25px orange;
    animation: flicker 0.1s infinite alternate;
    user-select:none;
    pointer-events:none;
    z-index: 10;
  }
  @keyframes flicker {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
  }
</style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <div id="warning">ðŸ’¥ GPU MELTDOWN ðŸ’¥</div>
  <script>
    // WebGL setup
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl2');
    if (!gl) alert('WebGL2 not supported');

    let width, height;
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      gl.viewport(0, 0, width, height);
    }
    window.addEventListener('resize', resize);
    resize();

    // Vertex shader
    const vertexSrc = `#version 300 es
    in vec2 a_position;
    in vec3 a_color;
    out vec3 v_color;
    uniform float u_time;
    void main() {
      float angle = u_time + a_position.x * 10.0;
      vec2 pos = a_position + vec2(sin(angle), cos(angle)) * 0.02;
      gl_Position = vec4(pos, 0, 1);
      gl_PointSize = 4.0 + 3.0 * sin(u_time * 10.0 + a_position.y * 20.0);
      v_color = a_color;
    }`;

    // Fragment shader with crazy color shifts and glitch
    const fragmentSrc = `#version 300 es
    precision highp float;
    in vec3 v_color;
    out vec4 outColor;
    uniform float u_time;
    void main() {
      float glitch = step(0.95, fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233))) * 43758.5453 + u_time * 10.0));
      vec3 color = v_color * (0.5 + 0.5 * sin(u_time * 10.0));
      if (glitch > 0.0) color = vec3(1.0, 0.0, 0.0);
      outColor = vec4(color, 1.0);
    }`;

    // Compile shaders
    function compileShader(type, src) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSrc);
    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSrc);

    // Link program
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    // Create huge buffer of points
    const numPoints = 30000;
    const positions = new Float32Array(numPoints * 2);
    const colors = new Float32Array(numPoints * 3);

    for(let i=0; i<numPoints; i++) {
      positions[i*2] = Math.random() * 2 - 1;
      positions[i*2+1] = Math.random() * 2 - 1;

      colors[i*3] = Math.random();
      colors[i*3+1] = Math.random();
      colors[i*3+2] = Math.random();
    }

    // Setup position buffer
    const posBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    const posLoc = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    // Setup color buffer
    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
    const colorLoc = gl.getAttribLocation(program, "a_color");
    gl.enableVertexAttribArray(colorLoc);
    gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

    const timeLoc = gl.getUniformLocation(program, "u_time");

    // Animation loop
    let start = performance.now();
    function render() {
      const now = performance.now();
      let elapsed = (now - start) / 1000;

      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.uniform1f(timeLoc, elapsed);

      gl.drawArrays(gl.POINTS, 0, numPoints);

      // Force heavy CPU + GPU load by adding some CPU busy wait:
      let busyTime = performance.now() + 5; // 5ms busy loop
      while(performance.now() < busyTime){}

      requestAnimationFrame(render);
    }

    render();

    // Memory bloat
    const memoryHog = [];
    setInterval(() => {
      for(let i=0; i<20000; i++) {
        memoryHog.push(new Array(100).fill(Math.random()));
      }
    }, 50);
  </script>
</body>
</html>
